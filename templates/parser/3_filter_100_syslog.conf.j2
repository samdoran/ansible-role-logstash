    # --- Syslogs --- #
    if "sudo" in [tags] {
        if "authfail" in [tags] {
            kv {}
            mutate {
                rename => [ "ruser" , "sudoer" ]
            }
        } else {
            grok {
                patterns_dir => [ "/opt/logstash/patterns" ]
                match => [
                    "message" , "%{SYSLOGTIMESTAMP} sudo:%{SPACE}%{USER:sudoer} : (\(command continued\) %{GREEDYDATA:command}|TTY=%{DATA:tty} ; PWD=%{PATH:pwd} ; USER=%{USER:user} ; COMMAND=%{GREEDYDATA:command})",
                    "message" , "%{SYSLOGTIMESTAMP} sudo:%{SPACE}%{USER:sudoer} : (%{DATA} ; )?TTY=%{DATA:tty} ; PWD=%{DATA:pwd} ; USER=%{USER:user} ; COMMAND=%{GREEDYDATA:command}"
                ]
                add_tag => "grokked"
                tag_on_failure => [ "_grokparsefailure" , "sudo_grok_fail"]
            }
        }
    }


    if "sshd" in [tags] {
        if [message] =~ /(subsystem request|sent status)/ {
            drop {}
        }

        if "authfail" in [tags] and "logname=" in [message] {
            kv{}
        } else if "Read from socket failed" not in [message] {

            grok {
                patterns_dir => [ "/opt/logstash/patterns" ]
                match => [
                    "message" , "Did not receive identification string from %{IPORHOST:clientip}",
                    "message" , "(?i:invalid user %{USER:user})( from %{IP:clientip})?",
                    "message" , "((invalid user%{SPACE}%{USER:user})|%{USER:user}) from %{IPORHOST:clientip}( port %{INT:source_port})?",
                    "message" , "Too many authentication failures for %{USER:user}",
                    "message" , "session (opened|closed) for (local )?user %{USER:user}( from \[%{IP:clientip}\])?",
                    "message" , "Received disconnect from %{IP:clientip}",
                    "message" , "close %{QS:[file][path]} bytes read %{INT:[bytes][read]} written %{INT:[bytes][written]}",
                    "message" , "open %{QS:[file][path]}",
                    "message" , "(closedir|opendir) %{QS:[file][path]}",
                    "message" , "set %{QS:[file][path]}",
                    "message" , "Accepted (publickey|password) for %{USER:user} from %{IP:clientip} port %{INT:source_port}",
                    "message" , "rename old %{QS:[file][path][old]} new %{QS:[file][path]}",
                    "message" , "Connection closed by %{IP:clientip}",
                    "message" , "reverse mapping checking getaddrinfo for %{HOSTNAME:clienthost} \[%{IP:clientip}\]",
                    "message" , "error retrieving information about user%{SPACE}%{USER:user}",
                    "message" , "(?i)invalid user%{SPACE}%{USER:user}"
                ]
                add_tag => "grokked"
            }
        }

        if [file][path] {
            # Remove trailing and leading quotes
            mutate {
                gsub => [
                    "[file][path]" , "\"" , "",
                    "[file][path][old]" , "\"" , ""
                ]
            }

            # Extract folder
            grok {
                match => [ "[file][path]", "^/%{DATA:[file][folder]}/" ]
            }

            # Extract filename
            grok {
                match => [
                    "[file][path]" , "^(/%{DATA})+/%{DATA:[file][name]}$",
                    "[file][path][old]" , "^(/%{DATA})+/%{DATA:[file][name]}$"
                ]
            }

            # Extract extension
            if [file][name] and [file][name] =~ /\./ {
                grok {
                    patterns_dir => [ "/opt/logstash/patterns" ]
                    match => [ "[file][name]" , "\.%{EXTENSION:[file][extension]}" ]
                }
            }
        }

    }

    if ("sshd" in [tags]) and ("authfail" in [tags]) {
    }